KV1:

    О C++:
    Компилируемый: Программа преобразуется в машинный код перед выполнением.
    Статически типизированный: Типы переменных указываются заранее и проверяются на этапе компиляции.
    Высокого уровня: Предоставляет абстракции, близкие к человеческому языку.

    Основные типы данных:
    int: Целые числа.
    float: Числа с плавающей точкой (одинарной).
    double: Числа с плавающей точкой (двойной).
    char: Символы.
    bool: Логические значения.

    Диапазоны и размеры:
    int: -2,147,483,648 до 2,147,483,647.
    float: примерно -3.4e38 до 3.4e38.
    double: примерно -1.7e308 до 1.7e308.
    char: обычно -128 до 127 или 0 до 255.
    bool: обычно 1 байт.

    Определение и объявление:
    Определение: Устанавливает память и начальное значение. Пример: int x = 10;.
    Объявление: Предоставляет информацию о типе. Пример: extern int y;.

    Арифметические операторы для целых типов:
    +, -, *, /, %.

KV2:
    Структура памяти процесса:
        Текстовый сегмент: Исполняемый код.
        Сегмент данных: Глобальные и статические переменные.
        Стек: Управление вызовами функций и локальными переменными.
        Куча: Динамически выделяемая область памяти.

    Связь встроенных указателей и массивов:
        Имя массива в C++ — это указатель на его первый элемент.    

    Почему низкоуровневая работа с памятью не безопасна:
        Может привести к ошибкам и уязвимостям безопасности, таким как утечки памяти и переполнения буфера.

    Адресуемая оперативная память:
        16 бит: 64 КБ.
        32 бит: Около 4 ГБ.
        64 бит: Очень много (до 18.4 миллионов терабайт).

    new, malloc, calloc - отличия:
        new (C++): Динамическое выделение с вызовом конструктора.
        malloc (C): Выделение блока памяти без вызова конструктора.
        calloc (C): Выделение блока с инициализацией нулями, также без вызова конструктора.
    
KV3:
    Поведение при передаче в функцию:
        Переменные: По значению (копия).
        Указатели: По значению или по ссылке.
        Ссылки: По ссылке.

    Статические переменные в функциях:
        Сохраняют значение между вызовами.

    Аргументы функций по умолчанию:
        Позволяют вызывать функцию без всех параметров.

    Выбор перегруженной функции:
        Основан на типах и количестве аргументов.

    Отличия inline функций от макросов:
        Inline функции: Компилируются как обычные функции.
        Макросы: Заменяются прямо в коде, могут быть менее безопасными.

KV4:
    Задание значений для данных-членов структуры:
        Конструктор, прямое присваивание, инициализация при объявлении.

    std::numeric_limits<double>::epsilon():
        Минимальная разница между числами double.

    Отличие структур и классов в C++:
        Структуры: Члены по умолчанию public, удобны для простых данных.

    Конструкторы и деструкторы:
        Конструкторы инициализируют, деструкторы освобождают ресурсы.

    Проблемы при работе с числами в C++:
        Целые: Переполнение, деление на ноль.
        Вещественные: Ограниченная точность представления.
        В Python: Гибче, меньше проблем с размером чисел.

KV5:
    Пространства имен:
        Зачем нужны: Избегание конфликтов имен, организация кода.
        Аддитивность: Возможность добавления элементов в пространство имен без изменения существующего кода.
        Вложенность: Пространства имен могут вкладываться для структурирования.

    Единица трансляции:
        Определение: Один компилируемый файл (обычно .cpp), проходящий через компиляцию и создающий объектный файл (.obj).

    Линковка (связывание):
        Определение: Процесс объединения объектных файлов и библиотек в исполняемый файл.
        Когда происходит: На этапе создания исполняемого файла после компиляции всех единиц трансляции.

    Предназначение .h (.hpp) файлов:
        .h (.hpp) файлы: Хранят объявления функций, классов и переменных, которые используются в других единицах трансляции.
        Куда подключать хедеры: В тех файлах, где нужны объявления для использования, и в соответствующих .cpp файлах для определения.

KV6:
    Классификация операторов:
        Арность, ассоциативность, приоритет, порядок вычисления, использование.

    Перегрузка операторов:
        Определение пользовательских действий для операторов. Операторы по умолчанию выполняют стандартные действия.

    Инкапсуляция:
        Сокрытие реализации объекта, предоставление интерфейса.

    Внешнее и внутреннее связывание:
        Глобальные переменные и функции видны за пределами файла (внешнее).
        Переменные и функции видны только внутри файла (внутреннее).

    Ключевое слово const:
        Обозначает неизменяемость.
        Константные переменные, указатели, функции и методы.

KV7:
    virtual, final, override для методов:
        virtual: Позволяет переопределять методы в производных классах.
        final: Запрещает дальнейшее переопределение метода.
        override: Указывает, что метод переопределяет виртуальный метод.

    Интерфейс (на человеческом языке):
        Способ взаимодействия объектов через их методы и свойства.

    Понятия:
        Виртуальная функция: Метод, который может быть переопределен в производных классах.
        Чистая виртуальная функция: Виртуальная функция без определения, создающая абстрактный класс.
        Абстрактный класс: Класс для наследования с хотя бы одной чистой виртуальной функцией.
        Интерфейсный класс: Класс с чистыми виртуальными функциями для реализации в производных классах.

    Идиома RAII:
        Управление ресурсами через их инициализацию и деинициализацию.

    Доступность полей базового класса при наследовании:
        Public наследование: Поля становятся public.
        Protected наследование: Поля становятся protected.
        Private наследование: Поля становятся private.

KV8:
    Типы выражений в C++:
        Арифметические, логические, отношения, присваивания, условные, битовые, указателей, вызова функций и т.д.

    Rvalue ссылки:
        Позволяют эффективно работать с временными значениями.
        Могут быть привязаны к lvalue или rvalue.

    Семантика перемещения и копирования:
        Перемещение: Передача ресурсов без копирования.
        Копирование: Создание копии с выделением новых ресурсов.
        Реализация: Перегрузка конструкторов и операторов, использование rvalue ссылок.

    std::move:
        Преобразует lvalue в rvalue, позволяя использовать семантику перемещения.

    Правила 3х и 5ти:
        Правило 3х: Определить деструктор, конструктор копирования, оператор присваивания.
        Правило 5ти: Добавить конструктор и оператор перемещения.

    Сигнатура специальных функций:
        Копирование: Type(const Type& other).
        Перемещение: Type(Type&& other) noexcept.

    Спровоцировать перемещающие операции:
        Передать rvalue ссылку в качестве аргумента или использовать std::move.

    Вызов с аргументом rvalue ссылкой:
        Может привести к неожиданному поведению.

    Ключевые слова default и delete:
        default: Генерация компилятором функции по умолчанию.
        delete: Запрещение компилятору генерировать функцию.

    Return Value Optimization (RVO):
        Определение: Оптимизация, избегающая создание временных копий объектов при возврате из функции.

    Обработка ошибок:
        Значение "обработать ошибку": Реагировать на ошибку.
        Способы: Возвращение кодов ошибок, исключения, обработка ошибок через объекты.

    Механизм исключений:
        Механизм: Обработка и передача ошибок через исключения.
        Достоинства: Разделение кода обработки ошибок и основной логики.
        Недостатки: Возможно влияние на производительность, требует осторожного использования.

    Сворачивание стека, noexcept, std::terminate():
        Сворачивание стека: Уничтожение локальных переменных при выбрасывании исключений.
        noexcept: Указывает, что функция не выбрасывает исключений.
        std::terminate(): Вызывается при необработанных исключениях, завершает программу.

    Обработка исключений различных типов, множественность блоков catch:
        Обработка: По типу исключения.
        Множественность блоков catch: Возможность использовать несколько блоков catch для разных типов исключений.

    Недостатки механизма исключений:
        Производительность: Может снижать производительность.
        Недетерминированность: Усложняет понимание потока выполнения программы.



